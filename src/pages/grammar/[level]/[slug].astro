---
import { getCollection } from 'astro:content';
import GrammarPostLayout from '../../../layouts/GrammarPostLayout.astro';
import ImageViewer from '../../../components/common/ImageViewer.astro';
import PDFGenerator from '../../../components/common/PDFGenerator.astro';
import ShareButton from '../../../components/common/ShareButton.astro';
import NavigationButtons from '../../../components/grammar/NavigationButtons.astro';
import RelatedGrammar from '../../../components/grammar/RelatedGrammar.astro';
import TableOfContents from '../../../components/grammar/TableOfContents.astro';
import '../../../styles/markdown.css';

/**
 * Grammar Post Page
 * 
 * Dynamic route: /grammar/[level]/[slug]
 * Renders individual grammar articles.
 */

// 1. Static Paths
export async function getStaticPaths() {
  const grammarEntries = await getCollection('grammar');
  
  return Promise.all(
    grammarEntries.map(async (entry) => {
      const rendered = await entry.render();
      const slug = entry.data.slug || entry.slug;
      
      return {
        params: { level: entry.data.level, slug: slug },
        props: { entry, content: rendered }
      };
    })
  );
}

// 2. Props & Data
const { entry, content } = Astro.props;
const { Content, headings } = content;
const { title, meaning, level, description, tags } = entry.data;

// 3. Context Data
const allGrammar = await getCollection('grammar');
const cleanGrammar = allGrammar.filter(g => !g.slug.endsWith('-draft') && !g.slug.endsWith('-original'));

// Sort for navigation context
const sortedGrammar = cleanGrammar.sort((a, b) => {
  const levelOrder = { beginner: 1, intermediate: 2, advanced: 3 };
  if (levelOrder[a.data.level] !== levelOrder[b.data.level]) {
    return levelOrder[a.data.level] - levelOrder[b.data.level];
  }
  return a.data.order - b.data.order;
});

// Previous/Next
const currentIndex = sortedGrammar.findIndex(g => {
  const gSlug = g.data.slug || g.slug;
  const entrySlug = entry.data.slug || entry.slug;
  return gSlug === entrySlug;
});
const prevGrammar = currentIndex > 0 ? sortedGrammar[currentIndex - 1] : null;
const nextGrammar = currentIndex < sortedGrammar.length - 1 ? sortedGrammar[currentIndex + 1] : null;

// Related
const relatedGrammar = allGrammar
  .filter(g => g.slug !== entry.slug)
  .filter(g => {
    const commonTags = tags?.filter((tag: string) => g.data.tags?.includes(tag)) || [];
    if (commonTags.length > 0) return true;
    return g.data.level === level;
  })
  .slice(0, 3);

// Mappings
const levelMap = { beginner: 'Sơ cấp', intermediate: 'Trung cấp', advanced: 'Cao cấp' };
const levelColorMap = {
  beginner: 'bg-emerald-100 text-emerald-700',
  intermediate: 'bg-amber-100 text-amber-700',
  advanced: 'bg-rose-100 text-rose-700'
};

// Formatted Headings for TOC
const tocHeadings = headings.map((h: any) => ({
  id: h.slug,
  text: h.text,
  level: h.depth
}));
---

<GrammarPostLayout title={title} description={description} showTOC={tocHeadings.length > 0}>
  
  <!-- TOC Slot -->
  <div slot="toc" class="h-full">
    <TableOfContents headings={tocHeadings} />
  </div>

  <!-- Main Content Article -->
  <article class="prose prose-slate max-w-none">
    
    <!-- 1. Header Section -->
    <header class="border-b border-slate-100 pb-8 mb-8 text-center sm:text-left">
      <!-- Back Link (Mobile only) -->
      <a href="/grammar" class="inline-flex items-center text-sm text-slate-500 hover:text-indigo-600 mb-6 lg:hidden group">
        <svg class="w-4 h-4 mr-1 group-hover:-translate-x-1 transition-transform" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 19l-7-7 7-7"></path></svg>
        Quay lại danh sách
      </a>

      <!-- Badges -->
      <div class="flex flex-wrap items-center gap-3 mb-4 justify-center sm:justify-start">
        <span class={`px-3 py-1 rounded-full text-xs font-bold uppercase tracking-wide ${levelColorMap[level]}`}>
          {levelMap[level]}
        </span>
        {tags?.map((tag: string) => (
          <span class="px-2.5 py-1 rounded-full text-xs font-medium bg-slate-100 text-slate-600">
            #{tag}
          </span>
        ))}
      </div>

      <!-- Title & Meaning -->
      <h1 class="text-3xl sm:text-4xl font-extrabold text-slate-800 mb-2 leading-tight">
        {title} 
      </h1>
      <p class="text-xl sm:text-2xl text-indigo-600 font-medium mb-6">
        {meaning}
      </p>

      <!-- Description -->
      {description && (
        <div class="bg-indigo-50/50 rounded-xl p-4 sm:p-6 border border-indigo-100 text-slate-600 leading-relaxed italic">
          <span set:html={description} />
        </div>
      )}
    </header>

    <!-- 2. Utility Bar -->
    <div class="flex items-center justify-between gap-4 mb-8 py-4 border-y border-slate-50 not-prose">
      <div class="flex gap-2">
        <ShareButton />
        <button onclick="window.print()" class="p-2 text-slate-400 hover:text-slate-600 hover:bg-slate-50 rounded-lg transition-colors" title="In bài viết">
          <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M17 17h2a2 2 0 002-2v-4a2 2 0 00-2-2H5a2 2 0 00-2 2v4a2 2 0 002 2h2m2 4h6a2 2 0 002-2v-4a2 2 0 00-2-2H9a2 2 0 00-2 2v4a2 2 0 002 2zm8-12V5a2 2 0 00-2-2H9a2 2 0 00-2 2v4h10z"></path></svg>
        </button>
      </div>
      <div>
         <!-- PDF Generator can be placed here -->
         <PDFGenerator 
            markdown={entry.body}
            slug={entry.slug}
            title={title}
            meaning={meaning}
            level={level}
            description={description}
            tags={tags}
         />
      </div>
    </div>

    <!-- 3. Markdown Body -->
    <div class="grammar-content markdown-content min-h-[300px]">
      <div class="prose-headings:scroll-mt-28">
        <Content />
      </div>
    </div>

    <!-- 4. Image Viewer (Hidden by default, triggered by JS) -->
    <ImageViewer />

    <!-- 5. Navigation Footer -->
    <footer class="mt-16 pt-8 border-t border-slate-100 not-prose">
      <NavigationButtons 
        prevGrammar={prevGrammar ? { level: prevGrammar.data.level, slug: prevGrammar.data.slug || prevGrammar.slug } : undefined}
        nextGrammar={nextGrammar ? { level: nextGrammar.data.level, slug: nextGrammar.data.slug || nextGrammar.slug } : undefined}
        showBackButton={false}
      />

      <div class="mt-12">
        <h3 class="text-lg font-bold text-slate-800 mb-6">Ngữ pháp liên quan</h3>
        <RelatedGrammar 
          relatedGrammar={relatedGrammar.map(g => ({
            title: g.data.title,
            meaning: g.data.meaning,
            level: g.data.level,
            slug: g.data.slug || g.slug
          }))} 
        />
      </div>
    </footer>

  </article>

</GrammarPostLayout>

<script>
/**
 * Grammar Post Client Logic
 * 
 * Responsibilities:
 * 1. Syntax Highlighting: Automatically highlights grammar terms.
 * 2. Visual Indicators: Styles (O), (X), (?) markers.
 * 3. Copy-to-clipboard: Interactions for headings.
 */

document.addEventListener('DOMContentLoaded', () => {
    
    // --- Configuration ---
    // List of grammar terms to highlight.
    // ORDER MATTERS: Longer terms first to prevent partial matching.
    const GRAMMAR_KEYWORDS = [
      '목적격조사', '부사격조사', '서술격조사', '선어말어미', '연결어미', '종결어미',
      '어말어미', '존칭어',
      '주격조사', '보격조사', '접속조사', '서술어', '형용사', '관형사',
      '대명사', '형태소', '높임말', '낮춤말', '표준어',
      '조사', '명사', '동사', '어미', '받침', '부사', '수사',
      '감탄사', '체언', '용언', '단어', '문장', '문법', '활용',
      '어간', '반말', '방언'
    ];

    /**
     * Highlights predefined grammar keywords within text nodes of the content.
     * Uses a tree walker to safely modify text without breaking HTML structure.
     */
    function highlightKeywords() {
      const contentRoot = document.querySelector('.grammar-content');
      if (!contentRoot) return;

      // Helper to process a single text node
      const processTextNode = (node: Text) => {
        const text = node.textContent || '';
        if (!text.trim()) return null;

        let modified = false;
        let html = text;

        // Sort keywords for greedy matching (longest first)
        // Note: Ideally this should be done once outside, but for safety in the loop...
        // Actually, let's just do a simple replace, but we need to be careful not to replace inside tags if we were operating on HTML strings.
        // Since we are operating on a TextNode, we are safe from HTML tag collision, BUT we need to return HTML to replace the TextNode.
        
        // We will construct a regex that matches ANY of the keywords
        // Optimized: Create regex once
        const regex = new RegExp(`(${GRAMMAR_KEYWORDS.join('|')})`, 'g'); // Simple match, case-sensitive usually ok for Korean
        
        if (regex.test(text)) {
           const fragment = document.createDocumentFragment();
           let lastIndex = 0;
           regex.lastIndex = 0; // Reset
           
           let match;
           while ((match = regex.exec(text)) !== null) {
             // Text before match
             const before = text.slice(lastIndex, match.index);
             if (before) fragment.appendChild(document.createTextNode(before));
             
             // Highlighted Match
             const span = document.createElement('span');
             span.className = 'text-indigo-600 font-medium bg-indigo-50 px-1 rounded mx-0.5'; // Tailwind Highlight
             span.textContent = match[0];
             fragment.appendChild(span);
             
             lastIndex = regex.lastIndex;
             modified = true;
           }
           
           // Text after last match
           const after = text.slice(lastIndex);
           if (after) fragment.appendChild(document.createTextNode(after));
           
           return modified ? fragment : null;
        }
        return null;
      };

      // Traverse text nodes
      // Restrict to p, li, td to avoid active elements or headings if desired. 
      // Current design targets 'p, li, td, blockquote'
      const walker = document.createTreeWalker(
        contentRoot,
        NodeFilter.SHOW_TEXT,
        {
          acceptNode: (node) => {
             const parent = node.parentElement;
             if (!parent) return NodeFilter.FILTER_REJECT;
             // Skip if already highlighted or in protected tags
             if (parent.tagName === 'SPAN' || parent.tagName === 'CODE' || parent.tagName === 'PRE' || parent.tagName === 'A') {
               return NodeFilter.FILTER_REJECT;
             }
             return NodeFilter.FILTER_ACCEPT;
          }
        }
      );

      const nodesToReplace: { node: Text, fragment: DocumentFragment }[] = [];
      
      while(walker.nextNode()) {
         const node = walker.currentNode as Text;
         const fragment = processTextNode(node);
         if (fragment) {
           nodesToReplace.push({ node, fragment });
         }
      }

      // Batch replace
      nodesToReplace.forEach(({ node, fragment }) => {
         node.replaceWith(fragment);
      });
    }

    /**
     * Styles (O), (X), (?) indicators better.
     */
     function styleIndicators() {
        const content = document.querySelector('.grammar-content');
        if (!content) return;
        
        // Targeting table cells mostly
        const cells = content.querySelectorAll('td, li, p');
        cells.forEach(el => {
           // Simple HTML replace is risky but effective for specific symbols
           // Using function to ensure we don't break tags
           // But here we just want to wrap strict strings like (O)
           
           let html = el.innerHTML;
           let changed = false;
           
           if (html.includes('(O)')) {
             html = html.replace(/\(O\)/g, '<span class="text-emerald-600 font-bold bg-emerald-50 px-1.5 rounded mr-1">Correct</span>');
             changed = true;
           }
           if (html.includes('(X)')) {
             html = html.replace(/\(X\)/g, '<span class="text-rose-600 font-bold bg-rose-50 px-1.5 rounded mr-1">Incorrect</span>');
             changed = true;
           }
           
           // If we changed innerHTML, update element
           if (changed) el.innerHTML = html;
        });
     }

     // --- Run Enhancements ---
     highlightKeywords();
     styleIndicators();

     // --- Heading Copy Logic ---
     document.querySelectorAll('.grammar-content h2, .grammar-content h3').forEach(h => {
        h.classList.add('group', 'cursor-pointer', 'relative');
        h.addEventListener('click', () => {
           const id = h.id;
           if(id) {
             const url = window.location.origin + window.location.pathname + '#' + id;
             navigator.clipboard.writeText(url).then(() => {
                // Could show toast here
                alert('Đã sao chép liên kết!');
             });
             history.pushState(null, '', '#' + id);
           }
        });
     });

});
</script>
