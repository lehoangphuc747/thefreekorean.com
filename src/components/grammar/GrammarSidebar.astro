---
import { getCollection } from 'astro:content';
import './GrammarSidebar.css';

const allGrammarRaw = await getCollection('grammar');

// Lọc bỏ các bài dành cho giáo viên (-gv) và bài nháp (-draft, -original) khỏi sidebar
const allGrammar = allGrammarRaw.filter(entry => {
  return !entry.slug.endsWith('-gv') && 
         !entry.slug.endsWith('-draft') && 
         !entry.slug.endsWith('-original');
});

const sortedGrammar = allGrammar.sort((a, b) => {
  const levelOrder = { beginner: 1, intermediate: 2, advanced: 3 };
  if (levelOrder[a.data.level] !== levelOrder[b.data.level]) {
    return levelOrder[a.data.level] - levelOrder[b.data.level];
  }
  return a.data.order - b.data.order;
});

const levelMap = {
  beginner: 'Sơ cấp',
  intermediate: 'Trung cấp',
  advanced: 'Cao cấp'
};

type GrammarEntry = (typeof sortedGrammar)[number];
type LevelKey = keyof typeof levelMap;

const levelKeys: LevelKey[] = ['beginner', 'intermediate', 'advanced'];

const groupedGrammar: Record<LevelKey, GrammarEntry[]> = {
  beginner: [],
  intermediate: [],
  advanced: []
};

sortedGrammar.forEach((entry) => {
  groupedGrammar[entry.data.level as LevelKey].push(entry);
});

const totalCount = sortedGrammar.length;
---

<aside class="grammar-sidebar" id="grammar-sidebar">
  <div class="sidebar-header-wrapper">
    <div class="sidebar-header">
      <div class="sidebar-heading">
        <h2 class="sidebar-title">Ngữ pháp</h2>
        <span class="sidebar-count">{totalCount} mẫu câu</span>
      </div>

      <!-- Toggle hide/show sidebar -->
      <button class="sidebar-toggle" id="sidebar-toggle" aria-label="Ẩn sidebar" aria-expanded="true" title="Ẩn sidebar (Ctrl+B)">
        <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
          <rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect>
          <line x1="9" y1="3" x2="9" y2="21"></line>
        </svg>
      </button>
    </div>

    <div class="sidebar-search-wrapper">
      <svg class="sidebar-search-icon" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
        <circle cx="11" cy="11" r="7" />
        <line x1="21" y1="21" x2="16.65" y2="16.65" />
      </svg>
      <input id="sidebar-search-input" type="text" placeholder="Tìm nhanh..." autocomplete="off" />
      <button id="sidebar-search-clear" aria-label="Xoá tìm kiếm" title="Xoá">
        <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
          <line x1="18" y1="6" x2="6" y2="18" />
          <line x1="6" y1="6" x2="18" y2="18" />
        </svg>
      </button>
    </div>
  </div>

  <div class="sidebar-content" id="sidebar-content">
    {levelKeys.map((level) => (
      <div class={['level-section', `level-${level}`].join(' ')} data-level-section={level}>
        <div class="level-header" data-level-toggle={level} role="button" aria-expanded="true">
          <div class="level-heading">
            <div class="level-pill" data-level={level}>{levelMap[level]}</div>
            <span class="level-count">{groupedGrammar[level].length}</span>
          </div>

          <button class="level-toggle" type="button" tabindex="-1">
            <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
              <polyline points="6 9 12 15 18 9" />
            </svg>
          </button>
        </div>

        <ul class="grammar-list" data-level-list={level}>
          {groupedGrammar[level].map((grammar) => (
            <li>
              <a
                href={`/grammar/${grammar.data.level}/${grammar.slug}`}
                class="grammar-item"
                data-level={grammar.data.level}
                data-slug={grammar.slug}
              >
                <span class="item-title" data-original-text={grammar.data.title}>{grammar.data.title}</span>
                <span class="item-meta">
                  <span class="item-meaning" data-original-text={grammar.data.meaning}>{grammar.data.meaning}</span>
                  {grammar.data.tags && grammar.data.tags.length > 0 && (
                    <span class="item-tags">
                      {grammar.data.tags.map((tag) => (
                        <span class="item-tag">{tag}</span>
                      ))}
                    </span>
                  )}
                </span>
              </a>
            </li>
          ))}
        </ul>
      </div>
    ))}

    <div class="sidebar-empty" data-empty-state hidden>
      <svg width="48" height="48" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5" style="margin: 0 auto; display: block; opacity: 0.3;">
        <circle cx="11" cy="11" r="8"></circle>
        <line x1="21" y1="21" x2="16.65" y2="16.65"></line>
      </svg>
      <p data-empty-text>Không tìm thấy ngữ pháp phù hợp.</p>
    </div>
  </div>
</aside>

<script>
  document.addEventListener('DOMContentLoaded', () => {
    const sidebar = document.getElementById('grammar-sidebar');
    if (!sidebar) return;

    const sidebarContainer = sidebar.closest('.grammar-container');
    const sidebarContent = document.getElementById('sidebar-content');
    const toggle = document.getElementById('sidebar-toggle');
    const searchInput = document.getElementById('sidebar-search-input') as HTMLInputElement | null;
    const clearButton = document.getElementById('sidebar-search-clear');
    const emptyState = sidebar.querySelector('[data-empty-state]') as HTMLElement | null;
    const emptyText = sidebar.querySelector('[data-empty-text]') as HTMLElement | null;
    const levelHeaders = Array.from(sidebar.querySelectorAll('[data-level-toggle]'));
    
    // State Management
    const SIDEBAR_STATE_KEY = 'tfk:grammarSidebarCollapsed';
    const EXPANDED_LEVELS_KEY = 'tfk:grammarExpandedLevels';

    // --- Helper Functions ---

    const syncSidebarLayout = () => {
      const collapsed = sidebar.classList.contains('collapsed');
      sidebarContainer?.classList.toggle('sidebar-collapsed', collapsed);
      return collapsed;
    };

    const saveState = (key: string, value: string) => {
      try { window.localStorage.setItem(key, value); } catch {}
    };

    const readState = (key: string) => {
      try { return window.localStorage.getItem(key); } catch { return null; }
    };

    // --- Collapsible Sidebar Logic ---
    
    const initSidebarState = () => {
      const stored = readState(SIDEBAR_STATE_KEY);
      if (stored === '1') {
        sidebar.classList.add('collapsed');
      } else {
        sidebar.classList.remove('collapsed');
      }
      syncSidebarLayout();
      updateToggleA11y();
    };

    const updateToggleA11y = () => {
      const collapsed = sidebar.classList.contains('collapsed');
      if (toggle) {
        toggle.setAttribute('aria-expanded', String(!collapsed));
        toggle.setAttribute('title', collapsed ? 'Hiện sidebar (Ctrl+B)' : 'Ẩn sidebar (Ctrl+B)');
      }
    };

    if (toggle) {
      toggle.addEventListener('click', () => {
        // Mobile logic
        if (window.matchMedia('(max-width: 1024px)').matches) {
          const willOpen = !sidebar.classList.contains('open');
          sidebar.classList.toggle('open', willOpen);
          if (willOpen) sidebar.classList.remove('collapsed');
          window.dispatchEvent(new CustomEvent('tfk:panel-state-change'));
          return;
        }
        // Desktop logic
        sidebar.classList.toggle('collapsed');
        const collapsed = syncSidebarLayout();
        saveState(SIDEBAR_STATE_KEY, collapsed ? '1' : '0');
        updateToggleA11y();
      });
    }

    // Keyboard Shortcut (Ctrl+B)
    document.addEventListener('keydown', (e) => {
      if ((e.ctrlKey || e.metaKey) && e.key.toLowerCase() === 'b') {
        e.preventDefault();
        toggle?.click();
      }
    });

    // Close on Click Outside (Mobile)
    document.addEventListener('click', (e) => {
      if (sidebar.classList.contains('open') && 
          e.target instanceof Node && 
          !sidebar.contains(e.target) && 
          e.target !== toggle) {
        sidebar.classList.remove('open');
        window.dispatchEvent(new CustomEvent('tfk:panel-state-change'));
      }
    });

    // --- Level Accordion Logic ---

    const toggleLevel = (level: string, show: boolean) => {
      const section = sidebar.querySelector(`[data-level-section="${level}"]`);
      const list = section?.querySelector('[data-level-list]');
      const header = section?.querySelector('[data-level-toggle]');
      const toggleIcon = header?.querySelector('.level-toggle');

      if (show) {
        list?.removeAttribute('hidden');
        header?.setAttribute('aria-expanded', 'true');
        toggleIcon?.setAttribute('aria-expanded', 'true');
      } else {
        list?.setAttribute('hidden', 'true');
        header?.setAttribute('aria-expanded', 'false');
        toggleIcon?.setAttribute('aria-expanded', 'false');
      }
    };

    // Click header to toggle
    levelHeaders.forEach(header => {
      header.addEventListener('click', () => {
        const level = (header as HTMLElement).dataset.levelToggle;
        const isExpanded = header.getAttribute('aria-expanded') === 'true';
        if (level) toggleLevel(level, !isExpanded);
      });
    });


    // --- Active Item & Auto-Scroll ---

    const highlightActiveAndAutoCollapse = () => {
      const currentPath = window.location.pathname;
      const items = Array.from(sidebar.querySelectorAll<HTMLAnchorElement>('.grammar-item'));
      let activeLevel: string | null = null;
      let foundActive = false;

      items.forEach((item) => {
        // Remove old highlights
        item.classList.remove('active');
        
        if (item.getAttribute('href') === currentPath && !foundActive) {
          item.classList.add('active');
          activeLevel = item.dataset.level || null;
          foundActive = true;
          
          // Auto scroll active item to center
          setTimeout(() => {
             item.scrollIntoView({ block: 'center', behavior: 'smooth' });
          }, 100);
        }
      });

      // Smart Collapse: Only open the active level on load, unless user searching
      const allLevels = Array.from(sidebar.querySelectorAll('[data-level-section]')).map(el => (el as HTMLElement).dataset.levelSection);
      
      // If we are on a grammar page, collapse others. If on index, maybe open all or first?
      // Let's default to: Open Active Level, Close Others.
      if (activeLevel) {
        allLevels.forEach(level => {
            if (level) toggleLevel(level, level === activeLevel);
        });
      } else {
        // If no active item (e.g. home page), open all for exploration
        allLevels.forEach(level => {
            if (level) toggleLevel(level, true);
        });
      }
    };


    // --- Search & Highlighting Logic ---

    const highlightText = (element: HTMLElement, text: string, keyword: string) => {
      if (!keyword) {
        element.textContent = text;
        return;
      }
      // Simple regex replace for highlighting
      const regex = new RegExp(`(${keyword.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')})`, 'gi');
      const parts = text.split(regex);
      
      element.innerHTML = parts.map(part => {
        if (part.toLowerCase() === keyword) {
          return `<span class="highlight-text">${part}</span>`;
        }
        return part; // Escape html if needed, but title/meaning are trusted
      }).join('');
    };

    const filterItems = () => {
      if (!searchInput) return;
      const keyword = searchInput.value.trim().toLowerCase();
      const isSearching = keyword.length > 0;
      let globalMatchCount = 0;

      // Handle clear button visibility
      if (clearButton) {
        if (isSearching) clearButton.classList.add('active');
        else clearButton.classList.remove('active');
      }

      const sections = sidebar.querySelectorAll('[data-level-section]');

      sections.forEach(section => {
        const sectionEl = section as HTMLElement;
        const level = sectionEl.dataset.levelSection;
        const list = sectionEl.querySelector('[data-level-list]');
        const items = list?.querySelectorAll('.grammar-item');
        let sectionMatchCount = 0;

        items?.forEach(item => {
          const itemEl = item as HTMLElement;
          const titleEl = itemEl.querySelector('.item-title') as HTMLElement;
          const meaningEl = itemEl.querySelector('.item-meaning') as HTMLElement;
          
          const originalTitle = titleEl.dataset.originalText || titleEl.textContent || '';
          const originalMeaning = meaningEl.dataset.originalText || meaningEl.textContent || '';
          const tags = Array.from(itemEl.querySelectorAll('.item-tag')).map(t => t.textContent?.toLowerCase()).join(' ');

          const match = !isSearching || 
                        originalTitle.toLowerCase().includes(keyword) || 
                        originalMeaning.toLowerCase().includes(keyword) ||
                        tags.includes(keyword);

          itemEl.parentElement?.toggleAttribute('hidden', !match);
          
          if (match) {
            sectionMatchCount++;
            globalMatchCount++;
            if (isSearching) {
              highlightText(titleEl, originalTitle, keyword);
              highlightText(meaningEl, originalMeaning, keyword);
            } else {
              // Restore original text
              titleEl.textContent = originalTitle;
              meaningEl.textContent = originalMeaning;
            }
          }
        });

        // Hide section if no matches
        sectionEl.style.display = (sectionMatchCount === 0 && isSearching) ? 'none' : '';
        
        // If searching, force expand matched sections
        if (isSearching && sectionMatchCount > 0 && level) {
           toggleLevel(level, true);
        }
      });

      // Empty State
      if (emptyState) {
        emptyState.hidden = globalMatchCount > 0;
        if (emptyText && isSearching) {
          emptyText.textContent = `Không tìm thấy kết quả cho "${keyword}"`;
        }
      }
    };

    // --- Event Listeners ---

    if (searchInput) {
      searchInput.addEventListener('input', filterItems);
      searchInput.addEventListener('keydown', (e) => {
        if (e.key === 'Escape') {
          searchInput.value = '';
          filterItems();
          searchInput.blur();
        }
      });
    }

    if (clearButton) {
      clearButton.addEventListener('click', () => {
        if (searchInput) {
          searchInput.value = '';
          searchInput.focus();
        }
        filterItems();
        // Reset view to active item state logic
        highlightActiveAndAutoCollapse();
      });
    }

    // Add visual scroll indicator for header border
    if (sidebarContent) {
      sidebarContent.addEventListener('scroll', () => {
        if (sidebarContent.scrollTop > 10) {
          sidebar.classList.add('has-scroll');
        } else {
          sidebar.classList.remove('has-scroll');
        }
      });
    }


    // Initialize
    initSidebarState();
    highlightActiveAndAutoCollapse();

    // Re-run on view transitions
    window.addEventListener('astro:after-swap', () => {
      initSidebarState();
      highlightActiveAndAutoCollapse();
    });
  });
</script>
