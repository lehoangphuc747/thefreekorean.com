---
/**
 * Component TopikExercise - Container ch√≠nh hi·ªÉn th·ªã b√†i luy·ªán t·∫≠p TOPIK
 * 
 * Ch·ª©c nƒÉng ch√≠nh:
 * - ƒê·ªçc v√† parse file JSON t·ª´ th∆∞ m·ª•c 'src/content/topik/dang-de/' d·ª±a tr√™n slug
 * - Validate c·∫•u tr√∫c JSON (ki·ªÉm tra meta, questions array)
 * - Hi·ªÉn th·ªã th√¥ng tin meta: title, level, range, v√† danh s√°ch c√°c k·ª≥ thi
 * - Nh√≥m c√¢u h·ªèi theo exam v√† s·∫Øp x·∫øp theo id
 * - X·ª≠ l√Ω c√°c lo·∫°i b√†i t·∫≠p kh√°c nhau (reading, listening, writing)
 * - Hi·ªÉn th·ªã h∆∞·ªõng d·∫´n chung cho nh√≥m c√¢u h·ªèi (group_instruction) n·∫øu c√≥
 * - Render danh s√°ch c√¢u h·ªèi th√¥ng qua component ReadingQuestion
 * - X·ª≠ l√Ω v√† hi·ªÉn th·ªã l·ªói n·∫øu file JSON kh√¥ng t·ªìn t·∫°i ho·∫∑c kh√¥ng h·ª£p l·ªá
 * 
 * State Management (NEW):
 * - questionOrder: 'order' | 'random' - Th·ª© t·ª± c√¢u h·ªèi
 * - checkMode: 'immediate' | 'submit' - Ki·ªÉm tra ngay ho·∫∑c sau khi n·ªôp
 * - selectedExam: string - K·ª≥ thi ƒëang ƒë∆∞·ª£c ch·ªçn
 * - showVietnamese: boolean - Hi·ªán/·∫©n b·∫£n d·ªãch m·∫∑c ƒë·ªãnh
 * - fontSize: 'small' | 'medium' | 'large' - C·ª° ch·ªØ
 * - currentQuestionIndex: number - C√¢u hi·ªán t·∫°i (quiz mode)
 * - userAnswers: Record<string, number> - ƒê√°p √°n ng∆∞·ªùi d√πng ƒë√£ ch·ªçn
 * - correctAnswers: Record<string, boolean> - ƒê√°p √°n ƒë√∫ng/sai
 * - bookmarkedQuestions: Set<string> - C√¢u ƒë√£ bookmark
 * - wrongQuestions: Set<string> - C√¢u tr·∫£ l·ªùi sai
 * 
 * Props:
 * - slug: T√™n file JSON (kh√¥ng bao g·ªìm .json extension)
 * 
 * C·∫•u tr√∫c JSON mong ƒë·ª£i:
 * {
 *   "meta": {
 *     "title": "Ti√™u ƒë·ªÅ b√†i t·∫≠p",
 *     "level": "TOPIK II",
 *     "range": "C√¢u 1-2",
 *     "type": "reading" | "listening" | "writing"
 *   },
 *   "questions": [
 *     {
 *       "id": 1,
 *       "exam": "91st",
 *       "group_instruction": "H∆∞·ªõng d·∫´n chung (optional)",
 *       "group_instruction_vi": "B·∫£n d·ªãch h∆∞·ªõng d·∫´n (optional)",
 *       "question_ko": "C√¢u h·ªèi ti·∫øng H√†n",
 *       ...
 *     }
 *   ]
 * }
 * 
 * Hi·ªán t·∫°i h·ªó tr·ª£:
 * - Reading: ƒê·∫ßy ƒë·ªß ch·ª©c nƒÉng
 * - Listening: ƒêang ph√°t tri·ªÉn
 * - Writing: ƒêang ph√°t tri·ªÉn
 */
import { readFileSync } from 'fs';
import { join } from 'path';
import ReadingQuestion from './ReadingQuestion.astro';
import SettingsPanel from './SettingsPanel.astro';
import ProgressBar from './ProgressBar.astro';
import ExamFilter from './ExamFilter.astro';
import TopikPrintStyles from './TopikPrintStyles.astro';

export interface Props {
  slug: string;
}

const { slug } = Astro.props;

// B∆∞·ªõc 1: ƒê·ªçc v√† ki·ªÉm tra JSON
const jsonPath = join(process.cwd(), 'src', 'content', 'topik', 'dang-de', `${slug}.json`);
let exerciseData: any = null;
let isValid = false;
let errorMessage = '';

try {
  const fileContent = readFileSync(jsonPath, 'utf-8');
  exerciseData = JSON.parse(fileContent);
  
  // Ki·ªÉm tra c·∫•u tr√∫c JSON
  if (!exerciseData.meta) {
    errorMessage = 'Thi·∫øu meta trong JSON';
  } else if (!exerciseData.questions) {
    errorMessage = 'Thi·∫øu questions trong JSON';
  } else if (!Array.isArray(exerciseData.questions)) {
    errorMessage = 'questions ph·∫£i l√† m·∫£ng';
  } else {
    isValid = true;
  }
} catch (error: any) {
  console.error('Error reading exercise file:', error);
  errorMessage = error.message || 'Kh√¥ng th·ªÉ ƒë·ªçc file JSON';
}

const meta = isValid ? exerciseData.meta : null;
const questions = isValid ? exerciseData.questions : [];
const exerciseType = meta?.type || '';

// L·∫•y danh s√°ch c√°c k·ª≥ thi t·ª´ questions
const exams: string[] = isValid 
  ? [...new Set(questions.map((q: any) => q.exam).filter(Boolean))] as string[]
  : [];

// Nh√≥m c√¢u h·ªèi theo exam v√† s·∫Øp x·∫øp theo id
const groupedQuestions: Record<string, any[]> = {};
if (isValid) {
  questions.forEach((q: any) => {
    const exam = q.exam || 'default';
    if (!groupedQuestions[exam]) {
      groupedQuestions[exam] = [];
    }
    groupedQuestions[exam].push(q);
  });
  // S·∫Øp x·∫øp m·ªói nh√≥m theo id
  Object.keys(groupedQuestions).forEach(exam => {
    groupedQuestions[exam].sort((a: any, b: any) => a.id - b.id);
  });
}

// ============================================================================
// STATE MANAGEMENT - Kh·ªüi t·∫°o c√°c state m·∫∑c ƒë·ªãnh
// ============================================================================

// Display & Interaction Settings
const initialQuestionOrder: 'order' | 'random' = 'order';
const initialCheckMode: 'immediate' | 'submit' = 'immediate';
const initialShowVietnamese = false;
const initialFontSize: 'small' | 'medium' | 'large' = 'medium';

// Exam & Navigation
const initialSelectedExam = 'all';

// Progress Tracking (s·∫Ω ƒë∆∞·ª£c qu·∫£n l√Ω trong client-side script)
// userAnswers: Record<questionId, selectedChoiceIndex>
// correctAnswers: Record<questionId, isCorrect>
// bookmarkedQuestions: Set<questionId> - l∆∞u trong localStorage
// wrongQuestions: Set<questionId> - l∆∞u trong localStorage

// Prepare data for SettingsPanel
const examsList = exams.map(exam => {
  const count = groupedQuestions[exam]?.length || 0;
  return { name: exam, count };
});

const totalQuestionsCount = questions.length;
---

<!-- Print Styles -->
<TopikPrintStyles />

<!-- Progress Bar - Fixed ·ªü ƒë·∫ßu page, ngay d∆∞·ªõi navbar -->
<div class="fixed top-[70px] left-0 right-0 z-50" id="topik-progress-bar">
  <ProgressBar
    totalQuestions={totalQuestionsCount}
    answeredQuestions={0}
    correctAnswers={0}
    wrongAnswers={0}
    bookmarkedCount={0}
  />
</div>

<div class="max-w-7xl mx-auto px-4 py-12" style="margin-top: 2rem;">
  {isValid ? (
    <>
      <!-- Back to luy·ªán t·∫≠p -->
      <div class="mb-4">
        <a href="/topik/luyen-tap" class="back-link">
          <span class="back-icon">‚Üê</span>
          Quay l·∫°i Luy·ªán t·∫≠p
        </a>
      </div>
      <!-- B∆∞·ªõc 2: Hi·ªÉn th·ªã Meta Info ·ªü ƒë·∫ßu trang -->
      <div class="text-center mb-8">
        <h1 class="text-4xl font-bold text-gray-900 mb-4">
          {meta.title}
        </h1>
        <div class="flex items-center justify-center gap-4 text-gray-600 flex-wrap">
          <span class="px-3 py-1 bg-blue-100 text-blue-800 rounded-full text-sm font-medium whitespace-nowrap">
            {meta.level}
          </span>
          <span class="px-3 py-1 bg-purple-100 text-purple-800 rounded-full text-sm font-medium whitespace-nowrap">
            {meta.range}
          </span>
        </div>
      </div>

      <!-- Settings Panel - Component m·ªõi (KH√îNG c√≥ ProgressBar n·ªØa) -->
      <SettingsPanel
        totalQuestions={totalQuestionsCount}
        answeredQuestions={0}
        correctAnswers={0}
        wrongAnswers={0}
        bookmarkedCount={0}
        questionOrder={initialQuestionOrder}
        checkMode={initialCheckMode}
        showVietnamese={initialShowVietnamese}
        showExplain={true}
        fontSize={initialFontSize}
        questionLimit={totalQuestionsCount}
        showProgressBar={false}
      />

      <!-- Exam Filter - Separate component below settings -->
      {examsList.length > 1 && (
        <div class="mb-8">
          <ExamFilter exams={examsList} selectedExams={[]} />
        </div>
      )}

      <!-- B∆∞·ªõc 3 & 4: Hi·ªÉn th·ªã theo type v√† l·∫∑p qua t·ª´ng c√¢u h·ªèi -->
      {exerciseType === 'reading' ? (
        <>
          {/* All Mode Container */}
          <div class="max-w-4xl mx-auto space-y-8" id="questions-container" data-display-mode="all">
            {Object.keys(groupedQuestions).map((exam: string) => {
              const examQuestions = groupedQuestions[exam];
              const firstQuestion = examQuestions[0];
              const hasGroupInstruction = firstQuestion.group_instruction;
              
              return (
                <div class="space-y-6" data-exam-group={exam}>
                  {/* Hi·ªÉn th·ªã h∆∞·ªõng d·∫´n chung cho nh√≥m (n·∫øu c√≥) */}
                  {hasGroupInstruction && (
                    <div class="group-instruction-card">
                      <div class="group-instruction-content">
                        <p class="group-instruction-ko">
                          {firstQuestion.group_instruction}
                        </p>
                        {firstQuestion.group_instruction_vi && (
                          <p class="group-instruction-vi">
                            {firstQuestion.group_instruction_vi}
                          </p>
                        )}
                      </div>
                    </div>
                  )}
                  
                  {/* Hi·ªÉn th·ªã c√°c c√¢u h·ªèi trong nh√≥m */}
                  <div class="questions-list" data-exam={exam}>
                    {examQuestions.map((question: any, index: number) => (
                      <div class="question-wrapper" data-question-order={question.id}>
                        <ReadingQuestion 
                          question={question}
                          checkMode={initialCheckMode}
                          isBookmarked={false}
                          fontSize={initialFontSize}
                          showVietnameseDefault={initialShowVietnamese}
                        />
                      </div>
                    ))}
                  </div>
                </div>
              );
            })}
          </div>
          
          {/* Submit All Button (only visible in submit mode) */}
          <div class="max-w-4xl mx-auto mt-8 hidden" id="submit-all-wrapper">
            <button 
              id="submit-all-btn"
              class="w-full py-4 px-6 bg-green-600 text-white text-lg font-bold rounded-xl hover:bg-green-700 transition-colors shadow-lg hover:shadow-xl"
            >
              üéØ N·ªôp b√†i v√† xem k·∫øt qu·∫£
            </button>
          </div>
          
          {/* Results Summary (shown after submit) */}
          <div class="max-w-4xl mx-auto mt-8 hidden" id="results-summary">
            <div class="bg-gradient-to-br from-blue-50 to-indigo-50 rounded-2xl shadow-xl p-6 border-2 border-blue-200">
              <h2 class="text-2xl font-bold text-gray-900 mb-6 text-center">üìä K·∫øt qu·∫£ l√†m b√†i</h2>
              
              {/* Stats Grid */}
              <div class="grid grid-cols-2 gap-4 mb-6">
                <div class="bg-white rounded-xl p-4 shadow-md text-center">
                  <div class="text-3xl font-bold text-green-600 mb-1" id="result-correct-count">0</div>
                  <div class="text-sm text-gray-600">C√¢u ƒë√∫ng</div>
                </div>
                <div class="bg-white rounded-xl p-4 shadow-md text-center">
                  <div class="text-3xl font-bold text-red-600 mb-1" id="result-wrong-count">0</div>
                  <div class="text-sm text-gray-600">C√¢u sai</div>
                </div>
                <div class="bg-white rounded-xl p-4 shadow-md text-center">
                  <div class="text-3xl font-bold text-blue-600 mb-1" id="result-answered-count">0</div>
                  <div class="text-sm text-gray-600">ƒê√£ ch·ªçn</div>
                </div>
                <div class="bg-white rounded-xl p-4 shadow-md text-center">
                  <div class="text-3xl font-bold text-gray-600 mb-1" id="result-unanswered-count">0</div>
                  <div class="text-sm text-gray-600">Ch∆∞a ch·ªçn</div>
                </div>
              </div>
              
              {/* Percentage */}
              <div class="text-center">
                <div class="inline-block bg-white rounded-xl p-4 shadow-md">
                  <div class="text-4xl font-bold text-indigo-600 mb-1" id="result-percentage">0%</div>
                  <div class="text-sm text-gray-600">T·ª∑ l·ªá l√†m ƒë√∫ng</div>
                </div>
              </div>
            </div>
          </div>
        </>
      ) : exerciseType === 'listening' ? (
        <div class="max-w-4xl mx-auto">
          <div class="bg-yellow-50 border-2 border-yellow-200 rounded-xl p-8 text-center">
            <p class="text-yellow-800">
              D·∫°ng listening - ƒêang ph√°t tri·ªÉn
            </p>
          </div>
        </div>
      ) : exerciseType === 'writing' ? (
        <div class="max-w-4xl mx-auto">
          <div class="bg-yellow-50 border-2 border-yellow-200 rounded-xl p-8 text-center">
            <p class="text-yellow-800">
              D·∫°ng writing - ƒêang ph√°t tri·ªÉn
            </p>
          </div>
        </div>
      ) : null}
    </>
  ) : (
    <!-- B∆∞·ªõc 1: Hi·ªÉn th·ªã l·ªói n·∫øu JSON kh√¥ng h·ª£p l·ªá -->
    <div class="max-w-4xl mx-auto">
      <div class="bg-red-50 border-2 border-red-200 rounded-xl p-8 text-center">
        <p class="text-red-800 text-lg font-medium mb-2">
          Kh√¥ng t√¨m th·∫•y d·ªØ li·ªáu cho slug n√†y.
        </p>
        <p class="text-red-600 text-sm">
          Slug: {slug}
        </p>
        {errorMessage && (
          <p class="text-red-600 text-sm mt-2">
            L·ªói: {errorMessage}
          </p>
        )}
      </div>
    </div>
  )}
</div>

<style>
  .back-link {
    display: inline-flex;
    align-items: center;
    gap: 0.5rem;
    padding: 0.5rem 0.75rem;
    background: #f1f5f9;
    color: #334155;
    border: 1px solid #e2e8f0;
    border-radius: 10px;
    font-weight: 600;
    text-decoration: none;
    transition: background 0.2s ease, color 0.2s ease, transform 0.1s ease;
  }
  .back-link:hover {
    background: #e2e8f0;
    color: #111827;
  }
  .back-icon {
    font-size: 1rem;
  }
  .group-instruction-card {
    background: linear-gradient(135deg, #fffbeb 0%, #fef3c7 100%);
    border: 1px solid #fcd34d;
    border-left: 4px solid #f59e0b;
    border-radius: 12px;
    padding: 1.25rem 1.5rem;
    margin-bottom: 1.5rem;
    box-shadow: 0 2px 8px rgba(245, 158, 11, 0.1);
    transition: all 0.2s ease;
  }

  .group-instruction-card:hover {
    box-shadow: 0 4px 12px rgba(245, 158, 11, 0.15);
    transform: translateY(-1px);
  }

  .group-instruction-content {
    display: flex;
    flex-direction: column;
    gap: 0.75rem;
  }

  .group-instruction-ko {
    font-family: 'Noto Sans KR', 'Malgun Gothic', 'ÎßëÏùÄ Í≥†Îîï', sans-serif;
    font-size: 1.125rem;
    font-weight: 600;
    color: #92400e;
    line-height: 1.6;
    margin: 0;
  }

  .group-instruction-vi {
    font-size: 0.9375rem;
    font-weight: 500;
    color: #78350f;
    line-height: 1.5;
    margin: 0;
    opacity: 0.9;
  }

  @media (max-width: 640px) {
    .group-instruction-card {
      padding: 1rem 1.25rem;
    }

    .group-instruction-ko {
      font-size: 1rem;
    }

    .group-instruction-vi {
      font-size: 0.875rem;
    }
  }

  /* Questions wrapper styling */
  .question-wrapper {
    margin-bottom: 2rem;
  }

  .questions-list {
    display: flex;
    flex-direction: column;
    gap: 2rem;
  }

  /* Font size classes */
  #questions-container.font-small {
    font-size: 0.875rem;
    line-height: 1.5;
  }

  #questions-container.font-medium {
    font-size: 1rem;
    line-height: 1.625;
  }

  #questions-container.font-large {
    font-size: 1.125rem;
    line-height: 1.75;
  }

  #questions-container.font-small .text-xl {
    font-size: 1.125rem;
  }

  #questions-container.font-large .text-xl {
    font-size: 1.5rem;
  }
</style>

<script define:vars={{ slug, totalQuestions: totalQuestionsCount }}>
  /**
   * TopikExercise Client-Side Logic
   * Qu·∫£n l√Ω state v√† x·ª≠ l√Ω events t·ª´ SettingsPanel
   */
  
  (function() {
    // ============================================================================
    // STATE MANAGEMENT
    // ============================================================================
    
    let state = {
      // Display & Interaction
      questionOrder: 'order',
      checkMode: 'immediate',
      showVietnamese: false,
      showExplain: true,
      fontSize: 'medium',
      questionLimit: totalQuestions, // S·ªë c√¢u ƒë·ªÉ h·ªçc
      
      // Navigation
      selectedExam: 'all',
      
      // Progress tracking
      userAnswers: {}, // { questionId: choiceIndex }
      correctAnswers: {}, // { questionId: isCorrect }
      bookmarkedQuestions: new Set(), // Set of questionIds
      wrongQuestions: new Set(), // Set of questionIds
      
      // Stats
      answeredCount: 0,
      correctCount: 0,
      wrongCount: 0
    };
    
    // ============================================================================
    // LOCALSTORAGE HELPERS
    // ============================================================================
    
    function loadFromLocalStorage() {
      try {
        // Load bookmarks
        const bookmarks = localStorage.getItem(`topik-bookmarks-${slug}`);
        if (bookmarks) {
          state.bookmarkedQuestions = new Set(JSON.parse(bookmarks));
        }
        
        // Load wrong answers
        const wrong = localStorage.getItem(`topik-wrong-${slug}`);
        if (wrong) {
          state.wrongQuestions = new Set(JSON.parse(wrong));
        }
        
        // Load font size preference
        const fontSize = localStorage.getItem('topik-font-size');
        if (fontSize && ['small', 'medium', 'large'].includes(fontSize)) {
          state.fontSize = fontSize;
          applyFontSize(fontSize);
        }
        
        // Load check mode preference
        const checkMode = localStorage.getItem('topik-check-mode');
        if (checkMode && ['immediate', 'submit'].includes(checkMode)) {
          state.checkMode = checkMode;
        }
        
        // Load question limit
        const questionLimit = localStorage.getItem(`topik-question-limit-${slug}`);
        if (questionLimit) {
          const limit = parseInt(questionLimit);
          if (!isNaN(limit) && limit >= 1 && limit <= totalQuestions) {
            state.questionLimit = limit;
          }
        }
      } catch (e) {
        console.error('Error loading from localStorage:', e);
      }
    }
    
    function saveToLocalStorage() {
      try {
        // Save bookmarks
        localStorage.setItem(`topik-bookmarks-${slug}`, 
          JSON.stringify([...state.bookmarkedQuestions]));
        
        // Save wrong answers
        localStorage.setItem(`topik-wrong-${slug}`, 
          JSON.stringify([...state.wrongQuestions]));
        
        // Save font size
        localStorage.setItem('topik-font-size', state.fontSize);
        
        // Save question limit
        localStorage.setItem(`topik-question-limit-${slug}`, state.questionLimit.toString());
      } catch (e) {
        console.error('Error saving to localStorage:', e);
      }
    }
    
    // ============================================================================
    // UTILITY FUNCTIONS
    // ============================================================================
    
    // Fisher-Yates shuffle
    function shuffleArray(array) {
      const shuffled = [...array];
      for (let i = shuffled.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
      }
      return shuffled;
    }
    
    // Apply font size to questions
    function applyFontSize(size) {
      const container = document.getElementById('questions-container');
      if (!container) return;
      
      container.classList.remove('font-small', 'font-medium', 'font-large');
      container.classList.add(`font-${size}`);
    }
    
    // Apply question limit - ·∫®n/hi·ªán c√¢u h·ªèi d·ª±a tr√™n limit
    function applyQuestionLimit(limit) {
      const container = document.getElementById('questions-container');
      if (!container) return;
      
      // L·∫•y t·∫•t c·∫£ question wrappers (c·∫£ trong exam groups v√† kh√¥ng)
      const questionWrappers = Array.from(container.querySelectorAll('.question-wrapper'));
      let visibleCount = 0;
      
      questionWrappers.forEach((wrapper) => {
        if (visibleCount < limit) {
          wrapper.style.display = '';
          visibleCount++;
        } else {
          wrapper.style.display = 'none';
        }
      });
    }
    
    // Reorder questions
    function reorderQuestions(mode) {
      const container = document.getElementById('questions-container');
      if (!container) return;
      
      if (mode === 'random') {
        // Collect ALL question wrappers from ALL exam groups
        const allWrappers = Array.from(container.querySelectorAll('.question-wrapper'));
        
        // Shuffle ALL questions together
        const shuffled = shuffleArray(allWrappers);
        
        // Detach all from DOM
        allWrappers.forEach(wrapper => wrapper.remove());
        
        // Find the questions-container and append all shuffled questions
        shuffled.forEach(wrapper => {
          container.appendChild(wrapper);
        });
      } else {
        // 'order' mode - keep original structure by exam groups
        const examGroups = container.querySelectorAll('[data-exam-group]');
        
        examGroups.forEach(group => {
          const questionsList = group.querySelector('.questions-list');
          if (!questionsList) return;
          
          const questionWrappers = Array.from(questionsList.querySelectorAll('.question-wrapper'));
          
          // Sort by original order
          questionWrappers.sort((a, b) => {
            const orderA = parseInt(a.getAttribute('data-question-order') || '0');
            const orderB = parseInt(b.getAttribute('data-question-order') || '0');
            return orderA - orderB;
          });
          
          // Re-append in order
          questionWrappers.forEach(wrapper => wrapper.remove());
          questionWrappers.forEach(wrapper => {
            questionsList.appendChild(wrapper);
          });
        });
      }
      
      // Sau khi reorder, √°p d·ª•ng question limit
      applyQuestionLimit(state.questionLimit);
    }
    
    // ============================================================================
    // CHECK MODE HELPERS
    // ============================================================================
    
    function updateAllQuestionsCheckMode(checkMode) {
      // Update data-check-mode attribute for all question containers
      const questions = document.querySelectorAll('[data-unique-question-id]');
      questions.forEach(q => {
        q.setAttribute('data-check-mode', checkMode);
      });
      
      // Dispatch event to notify questions
      const event = new CustomEvent('settings-change', {
        detail: { setting: 'checkMode', value: checkMode }
      });
      document.dispatchEvent(event);
    }
    
    function updateSettingsPanelCheckMode(checkMode) {
      // Update active state of checkMode buttons
      const panel = document.querySelector('[data-settings-panel]');
      if (!panel) return;
      
      const buttons = panel.querySelectorAll('[data-setting="checkMode"]');
      buttons.forEach(btn => {
        const btnValue = btn.getAttribute('data-value');
        if (btnValue === checkMode) {
          btn.classList.add('active');
        } else {
          btn.classList.remove('active');
        }
      });
    }
    
    function toggleSubmitAllButton(checkMode) {
      const submitAllWrapper = document.getElementById('submit-all-wrapper');
      if (!submitAllWrapper) return;
      
      if (checkMode === 'submit') {
        submitAllWrapper.classList.remove('hidden');
      } else {
        submitAllWrapper.classList.add('hidden');
      }
    }
    
    function handleSubmitAll() {
      // Calculate correct/wrong counts from stored answers
      // Only count questions that user has actually answered in this session
      state.correctCount = 0;
      state.wrongCount = 0;
      state.wrongQuestions.clear();
      
      console.log('handleSubmitAll - userAnswers keys:', Object.keys(state.userAnswers));
      console.log('handleSubmitAll - correctAnswers:', state.correctAnswers);
      
      // Only count answers that exist in userAnswers (avoid counting old data)
      Object.keys(state.userAnswers).forEach(questionId => {
        const isCorrect = state.correctAnswers[questionId];
        console.log(`Question ${questionId}: isCorrect = ${isCorrect}`);
        if (isCorrect === true) {
          state.correctCount++;
          state.wrongQuestions.delete(questionId);
        } else if (isCorrect === false) {
          state.wrongCount++;
          state.wrongQuestions.add(questionId);
        } else {
          console.warn(`Question ${questionId}: isCorrect is undefined or null`);
        }
      });
      
      console.log(`Final counts: correct=${state.correctCount}, wrong=${state.wrongCount}, answered=${Object.keys(state.userAnswers).length}`);
      
      saveToLocalStorage();
      updateProgressBar(); // Update with correct/wrong counts
      
      // Dispatch event to all questions to show their feedback
      const event = new CustomEvent('submit-all-answers', {
        bubbles: true
      });
      document.dispatchEvent(event);
      
      // Disable submit button
      const submitBtn = document.getElementById('submit-all-btn');
      if (submitBtn) {
        submitBtn.disabled = true;
        submitBtn.textContent = '‚úÖ ƒê√£ n·ªôp b√†i';
        submitBtn.classList.remove('bg-green-600', 'hover:bg-green-700');
        submitBtn.classList.add('bg-gray-400', 'cursor-not-allowed');
      }
      
      // Show results summary
      showResultsSummary();
    }
    
    function showResultsSummary() {
      const resultsSummary = document.getElementById('results-summary');
      if (!resultsSummary) return;
      
      // S·ª≠ d·ª•ng questionLimit thay v√¨ totalQuestions ƒë·ªÉ ƒë·ªìng b·ªô v·ªõi s·ªë c√¢u ƒë√£ ch·ªçn
      const total = state.questionLimit;
      const answered = state.answeredCount;
      const correct = state.correctCount;
      const wrong = state.wrongCount;
      const unanswered = total - answered;
      const percentage = answered > 0 ? Math.round((correct / answered) * 100) : 0;
      
      // Update the summary
      const correctEl = document.getElementById('result-correct-count');
      const wrongEl = document.getElementById('result-wrong-count');
      const answeredEl = document.getElementById('result-answered-count');
      const unansweredEl = document.getElementById('result-unanswered-count');
      const percentageEl = document.getElementById('result-percentage');
      
      if (correctEl) correctEl.textContent = correct;
      if (wrongEl) wrongEl.textContent = wrong;
      if (answeredEl) answeredEl.textContent = answered;
      if (unansweredEl) unansweredEl.textContent = unanswered;
      if (percentageEl) percentageEl.textContent = `${percentage}%`;
      
      // Show the summary
      resultsSummary.classList.remove('hidden');
      
      // Scroll to results
      resultsSummary.scrollIntoView({ behavior: 'smooth', block: 'start' });
    }
    
    // Update ProgressBar stats
    function updateProgressBar() {
      // Dispatch custom event to update ProgressBar component
      // Use questionLimit instead of totalQuestions to sync with user's selection
      const event = new CustomEvent('progress-update', {
        detail: {
          answeredCount: state.answeredCount,
          correctCount: state.correctCount,
          wrongCount: state.wrongCount,
          bookmarkedCount: state.bookmarkedQuestions.size,
          total: state.questionLimit // ƒê·ªìng b·ªô v·ªõi s·ªë c√¢u ƒë√£ ch·ªçn
        }
      });
      document.dispatchEvent(event);
    }
    
    // ============================================================================
    // QUESTION ORDERING & FILTERING
    // ============================================================================
    
    // ============================================================================
    // EXAM FILTER FUNCTIONS (Task 10)
    // ============================================================================
    
    function filterByExam(examName) {
      const allContainer = document.getElementById('questions-container');
      if (!allContainer) return;
      
      const examGroups = allContainer.querySelectorAll('[data-exam-group]');
      
      examGroups.forEach(group => {
        const groupExam = group.getAttribute('data-exam-group');
        
        if (examName === 'all' || groupExam === examName) {
          group.classList.remove('hidden');
        } else {
          group.classList.add('hidden');
        }
      });
      
      // Update stats
      updateStatsAfterFilter();
    }
    
    // New: Filter by multiple exams (OR logic)
    function filterByExams(exams) {
      const allContainer = document.getElementById('questions-container');
      if (!allContainer) return;
      
      const examGroups = allContainer.querySelectorAll('[data-exam-group]');
      
      // If no exams selected, show all
      if (!exams || exams.length === 0) {
        examGroups.forEach(group => group.classList.remove('hidden'));
        updateStatsAfterFilter();
        return;
      }
      
      // Otherwise show only selected exams
      examGroups.forEach(group => {
        const groupExam = group.getAttribute('data-exam-group');
        
        if (exams.includes(groupExam)) {
          group.classList.remove('hidden');
        } else {
          group.classList.add('hidden');
        }
      });
      
      // Update stats
      updateStatsAfterFilter();
    }
    
    function getFilteredQuestions() {
      const allContainer = document.getElementById('questions-container');
      if (!allContainer) return [];
      
      const questions = [];
      const examGroups = allContainer.querySelectorAll('[data-exam-group]');
      
      examGroups.forEach(group => {
        const isHidden = group.classList.contains('hidden');
        if (isHidden) return;
        
        const questionWrappers = group.querySelectorAll('.question-wrapper [data-unique-question-id]');
        questionWrappers.forEach(q => {
          questions.push({
            exam: q.getAttribute('data-question-exam'),
            id: q.getAttribute('data-question-id')
          });
        });
      });
      
      return questions;
    }
    
    function updateStatsAfterFilter() {
      const filteredQuestions = getFilteredQuestions();
      const totalFiltered = filteredQuestions.length;
      
      // Count answered in filtered set
      let answeredFiltered = 0;
      let correctFiltered = 0;
      let wrongFiltered = 0;
      
      filteredQuestions.forEach(q => {
        const qId = getQuestionId(q);
        if (state.userAnswers[qId] !== undefined) {
          answeredFiltered++;
          if (state.correctAnswers[qId]) correctFiltered++;
          else wrongFiltered++;
        }
      });
      
      // Dispatch event to update ProgressBar
      const event = new CustomEvent('progress-update', {
        detail: {
          total: totalFiltered,
          answeredCount: answeredFiltered,
          correctCount: correctFiltered,
          wrongCount: wrongFiltered,
          bookmarkedCount: state.bookmarkedQuestions.size
        }
      });
      document.dispatchEvent(event);
    }
    
    function getQuestionId(question) {
      return `${question.exam}-${question.id}`;
    }
    
    // ============================================================================
    // VIETNAMESE TOGGLE FUNCTION
    // ============================================================================
    
    function toggleVietnameseGlobal(show) {
      // Dispatch event to all questions
      const event = new CustomEvent('settings-change', {
        detail: { setting: 'showVietnamese', value: show }
      });
      document.dispatchEvent(event);
    }
    
    function toggleExplainGlobal(show) {
      // Dispatch event to all questions
      const event = new CustomEvent('settings-change', {
        detail: { setting: 'showExplain', value: show }
      });
      document.dispatchEvent(event);
    }
    
    // ============================================================================
    // EVENT HANDLERS
    // ============================================================================
    
    // Handle settings change from SettingsPanel
    function handleSettingsChange(event) {
      const { setting, value } = event.detail;
      
      console.log('Setting changed:', setting, value);
      
      switch (setting) {
        case 'questionOrder':
          // Allow re-shuffling even if already in random mode
          // This enables users to shuffle multiple times
          state.questionOrder = value;
          reorderQuestions(value);
          break;
          
        case 'checkMode':
          state.checkMode = value;
          // Save to localStorage and apply immediately
          localStorage.setItem('topik-check-mode', value);
          // Update all question containers' mode immediately
          updateAllQuestionsCheckMode(value);
          // Toggle submit all button visibility
          toggleSubmitAllButton(value);
          break;
          
        case 'showVietnamese':
          state.showVietnamese = value;
          toggleVietnameseGlobal(value);
          break;
          
        case 'showExplain':
          state.showExplain = value;
          toggleExplainGlobal(value);
          break;
          
        case 'fontSize':
          state.fontSize = value;
          applyFontSize(value);
          saveToLocalStorage();
          break;
          
        case 'questionLimit':
          state.questionLimit = value;
          applyQuestionLimit(value);
          // N·∫øu ƒëang ·ªü ch·∫ø ƒë·ªô random, reorder l·∫°i v·ªõi s·ªë c√¢u m·ªõi
          if (state.questionOrder === 'random') {
            reorderQuestions('random');
          }
          saveToLocalStorage();
          // C·∫≠p nh·∫≠t progress bar v·ªõi total m·ªõi
          updateProgressBar();
          break;
      }
    }
    
    // Handle reset exercise
    function handleReset() {
      console.log('Resetting exercise...');
      
      // Clear answers and stats
      state.userAnswers = {};
      state.correctAnswers = {};
      state.wrongQuestions.clear();
      state.answeredCount = 0;
      state.correctCount = 0;
      state.wrongCount = 0;
      
      // Keep bookmarks (intentionally)
      // But clear answers from localStorage
      try {
        localStorage.removeItem(`topik-wrong-${slug}`);
        localStorage.setItem(`topik-bookmarks-${slug}`, 
          JSON.stringify([...state.bookmarkedQuestions]));
      } catch (e) {
        console.error('Error clearing localStorage:', e);
      }
      
      // Update ProgressBar immediately
      updateProgressBar();
      
      // Reset UI - dispatch reset event to all questions
      const container = document.getElementById('questions-container');
      if (container) {
        const questions = container.querySelectorAll('[data-unique-question-id]');
        questions.forEach(q => {
          const resetEvent = new CustomEvent('reset-question', { bubbles: true });
          q.dispatchEvent(resetEvent);
        });
      }
      
      // Reset submit button if in submit mode
      const submitBtn = document.getElementById('submit-all-btn');
      if (submitBtn) {
        submitBtn.disabled = false;
        submitBtn.textContent = 'üéØ N·ªôp b√†i v√† xem k·∫øt qu·∫£';
        submitBtn.classList.remove('bg-gray-400', 'cursor-not-allowed');
        submitBtn.classList.add('bg-green-600', 'hover:bg-green-700');
      }
      
      // Scroll to top
      window.scrollTo({ top: 0, behavior: 'smooth' });
    }
    
    // ============================================================================
    // INITIALIZATION
    // ============================================================================
    
    document.addEventListener('DOMContentLoaded', () => {
      console.log('TopikExercise initialized');
      
      // Load saved data
      loadFromLocalStorage();
      
      // Apply question limit after loading
      applyQuestionLimit(state.questionLimit);
      
      // Lu√¥n set checkMode cho to√†n b·ªô c√¢u h·ªèi ƒë·ªÉ ƒë·ªìng b·ªô thu·ªôc t√≠nh
      updateAllQuestionsCheckMode(state.checkMode);
      
      // Update SettingsPanel checkMode buttons
      updateSettingsPanelCheckMode(state.checkMode);
      
      // Show/hide submit all button based on checkMode
      toggleSubmitAllButton(state.checkMode);
      
      // Listen to SettingsPanel events
      document.addEventListener('settings-change', handleSettingsChange);
      document.addEventListener('reset-exercise', handleReset);
      
      // Listen to submit all button
      const submitAllBtn = document.getElementById('submit-all-btn');
      if (submitAllBtn) {
        submitAllBtn.addEventListener('click', handleSubmitAll);
      }
      
      // Listen to other events (exam-change, timer, etc.)
      document.addEventListener('exam-change', (e) => {
        const exams = e.detail.exams; // Array of exam names
        state.selectedExam = exams.length === 1 ? exams[0] : 'all'; // For compatibility
        console.log('Exams changed:', exams);
        
        // Filter by multiple exams (OR logic)
        filterByExams(exams);
      });
      
      document.addEventListener('time-up', () => {
        console.log('Time is up!');
        // TODO: Auto-submit if in submit mode
      });
      
      // Listen to answer events from questions
      document.addEventListener('answer-submitted', (e) => {
        const { questionId, selectedIndex, isCorrect } = e.detail;
        
        // Only update if not already processed (avoid double counting)
        const wasAlreadyProcessed = state.userAnswers[questionId] !== undefined;
        
        state.userAnswers[questionId] = selectedIndex;
        state.correctAnswers[questionId] = isCorrect;
        
        // Only increment if this is a new answer
        if (!wasAlreadyProcessed) {
          if (isCorrect) {
            state.correctCount++;
            state.wrongQuestions.delete(questionId);
          } else {
            state.wrongCount++;
            state.wrongQuestions.add(questionId);
          }
        }
        
        state.answeredCount = Object.keys(state.userAnswers).length;
        
        saveToLocalStorage();
        updateProgressBar();
      });
      
      // Listen to answer-selected events (in submit mode - before submission)
      document.addEventListener('answer-selected', (e) => {
        const { questionId, selectedIndex, isCorrect } = e.detail;
        
        // Store answer but don't update correct/wrong counts yet
        state.userAnswers[questionId] = selectedIndex;
        state.answeredCount = Object.keys(state.userAnswers).length;
        
        // Temporarily store the correctness (will be revealed on submit)
        state.correctAnswers[questionId] = isCorrect;
        
        saveToLocalStorage();
        updateProgressBar(); // Update only answered count, not correct/wrong
      });
      
      // Listen to bookmark events
      document.addEventListener('bookmark-toggle', (e) => {
        const { questionId, isBookmarked } = e.detail;
        
        if (isBookmarked) {
          state.bookmarkedQuestions.add(questionId);
        } else {
          state.bookmarkedQuestions.delete(questionId);
        }
        
        saveToLocalStorage();
        updateProgressBar();
      });
    });
  })();
</script>

