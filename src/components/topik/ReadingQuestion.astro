---
/**
 * Component ReadingQuestion - Hiển thị một câu hỏi đọc hiểu TOPIK
 * 
 * Chức năng chính:
 * - Hiển thị câu hỏi bằng tiếng Hàn (question_ko) và có thể toggle hiện/ẩn bản dịch tiếng Việt (question_vi)
 * - Hiển thị hình ảnh đính kèm câu hỏi (nếu có)
 * - Render danh sách các lựa chọn trả lời thông qua component ChoiceList
 * - Xử lý logic chọn đáp án: kiểm tra đúng/sai, vô hiệu hóa sau khi chọn
 * - Hiển thị feedback (đúng/sai) với màu sắc tương ứng (xanh/đỏ)
 * - Hiển thị giải thích (explain) với markdown formatting (bold, italic, headings, bullet points)
 * - Sử dụng unique ID (exam-id) để tránh conflict khi có nhiều câu hỏi cùng số thứ tự
 * - State management riêng biệt cho mỗi câu hỏi thông qua IIFE closure
 * - Hỗ trợ 2 check mode: immediate (feedback ngay) và submit (feedback sau khi nộp)
 * - Bookmark functionality với star icon
 * 
 * Props:
 * - question.id: Số thứ tự câu hỏi
 * - question.exam: Mã đề thi (vd: "91st", "topik2-dang-01")
 * - question.question_ko: Câu hỏi tiếng Hàn
 * - question.question_vi: Bản dịch tiếng Việt (optional)
 * - question.image: Đường dẫn hình ảnh (optional)
 * - question.choices: Mảng các lựa chọn
 * - question.answer: Index đáp án đúng
 * - question.explain: Giải thích đáp án (optional, hỗ trợ markdown)
 * - checkMode: 'immediate' | 'submit' (default: 'immediate')
 * - isBookmarked: boolean (default: false)
 * - fontSize: 'small' | 'medium' | 'large' (default: 'medium')
 * - showVietnameseDefault: boolean (default: false)
 */
import ChoiceList from './ChoiceList.astro';

export interface Props {
  question: {
    id: number;
    exam: string;
    question_ko: string;
    question_vi?: string;
    image?: string;
    choices: Array<{ type: string; text?: string; src?: string; alt?: string }>;
    answer: number;
    explain?: string;
  };
  checkMode?: 'immediate' | 'submit';
  isBookmarked?: boolean;
  fontSize?: 'small' | 'medium' | 'large';
  showVietnameseDefault?: boolean;
}

const { 
  question, 
  checkMode = 'immediate',
  isBookmarked = false,
  fontSize = 'medium',
  showVietnameseDefault = false
} = Astro.props;
---

<div class="bg-white rounded-xl shadow-lg p-8" data-question-id={question.id} data-question-exam={question.exam} data-unique-question-id={`${question.exam}-${question.id}`} data-question-answer={question.answer} data-question-explain={question.explain || ''} data-check-mode={checkMode}>
  <!-- Số câu và câu hỏi tiếng Hàn -->
  <div class="mb-4">
    <div class="flex items-center gap-2 mb-2">
      <span class="text-sm font-medium text-gray-500">
        Câu {question.id}
      </span>
      {question.exam && (
        <span class="px-2 py-1 bg-green-100 text-green-700 rounded text-xs font-medium">
          {question.exam.toUpperCase()}
        </span>
      )}
      {question.question_vi && (
        <button 
          class="toggle-vietnamese-btn px-3 py-1 text-xs font-medium text-blue-600 bg-blue-50 rounded-lg hover:bg-blue-100 transition-colors whitespace-nowrap"
          data-question-id={question.id}
        >
          Hiện dịch
        </button>
      )}
      <button 
        class="toggle-explain-btn px-3 py-1 text-xs font-medium text-purple-600 bg-purple-50 rounded-lg hover:bg-purple-100 transition-colors whitespace-nowrap"
        type="button"
      >
        Hiện giải thích
      </button>
      {/* Bookmark Star Icon */}
      <button 
        class="bookmark-btn ml-auto text-xl transition-transform hover:scale-110"
        data-question-id={`${question.exam}-${question.id}`}
        data-is-bookmarked={isBookmarked}
        aria-label="Bookmark this question"
      >
        {isBookmarked ? '⭐' : '☆'}
      </button>
    </div>
    <div class="flex items-start justify-between gap-4">
      <h3 class="text-xl font-bold text-gray-900 mt-2 mb-2 flex-1 question-ko" set:html={question.question_ko}>
      </h3>
      
    </div>
    {question.question_vi && (
      <div 
        class="vietnamese-translation hidden text-sm text-gray-600 mb-4 mt-2"
        data-vietnamese-translation={question.id}
      >
        {question.question_vi}
      </div>
    )}
  </div>

  <!-- Hình ảnh (nếu có) -->
  {question.image && (
    <div class="mb-4">
      <img src={question.image} alt="Question image" class="rounded-lg max-w-full" />
    </div>
  )}

  <!-- Danh sách lựa chọn -->
  {question.choices && question.choices.length > 0 && (
    <>
      <div 
        class="mb-4"
        data-choice-list-container
        data-question-id={question.id}
        data-answer={question.answer}
      >
        <ChoiceList 
          choices={question.choices}
          answer={question.answer}
          selectedIndex={null}
          onSelect={(index) => {}}
        />
      </div>
      
      <!-- Feedback area (ẩn ban đầu, chỉ hiện trong immediate mode hoặc sau khi submit) -->
      <div 
        class="feedback-area hidden mb-4 p-4 rounded-lg"
        data-feedback-area
      >
        <p class="feedback-message text-base font-medium"></p>
        {question.explain && (
          <p class="feedback-explain mt-2 text-sm text-gray-700"></p>
        )}
      </div>
      
    </>
  )}
 </div>

<style>
  .question-ko {
    white-space: pre-wrap;
  }
  
  /* Style cho phần gạch chân trong câu hỏi */
  .question-ko u {
    background-color: #fee2e2;
    padding: 2px 4px;
    border-radius: 4px;
    display: inline-block;
    border-bottom: 3px solid #ef4444;
    padding-bottom: 4px;
  }
</style>

<script define:vars={{ questionId: question.id, uniqueQuestionId: `${question.exam}-${question.id}`, answerValue: question.answer, explainText: question.explain || '', checkModeValue: checkMode, showVietnameseDefaultValue: showVietnameseDefault }}>
  // Sử dụng IIFE để tạo closure riêng cho mỗi câu hỏi, tránh conflict state
  (function() {
    // State riêng cho câu hỏi này (isolated trong closure)
    let selectedIndex = null;
    let isCorrect = null;
    let showVietnamese = showVietnameseDefaultValue;
    let isSubmitted = false; // For submit mode
    let showExplain = true; // Default show explain
    
    // Helper to get current checkMode from container (can be updated dynamically)
    function getCurrentCheckMode() {
      const container = document.querySelector(`[data-unique-question-id="${uniqueQuestionId}"]`);
      return container?.getAttribute('data-check-mode') || checkModeValue;
    }
  
  function updateChoiceList(selectedIdx) {
    // Sử dụng unique ID để tránh conflict khi có nhiều câu cùng id nhưng khác exam
    const container = document.querySelector(`[data-unique-question-id="${uniqueQuestionId}"]`);
    if (!container) return;
    
    const choiceListContainer = container.querySelector('[data-choice-list-container]');
    const choiceList = choiceListContainer?.querySelector('[data-choice-list]');
    const choiceItems = choiceList?.querySelectorAll('.choice-item');
    
    if (!choiceItems) return;
    
    choiceItems.forEach((item, idx) => {
      const isSelected = selectedIdx === idx;
      // So sánh index gốc với answerValue để xác định đúng/sai (ổn định sau shuffle)
      const isAnswer = (item.getAttribute('data-original-index') === String(answerValue));
      const isSelectedAndCorrect = isSelected && isAnswer;
      const isSelectedAndWrong = isSelected && !isAnswer;
      const isCorrectAnswerButNotSelected = isAnswer && selectedIdx !== null && !isSelected;
      
      // Reset classes và styles
      item.className = "choice-item p-3 border-2 rounded-lg transition-colors cursor-pointer";
      item.style.opacity = '';
      
      if (selectedIdx === null) {
        // Chưa chọn - bình thường
        item.classList.add('border-gray-200', 'hover:border-blue-400');
        item.style.pointerEvents = '';
        item.removeAttribute('data-disabled');
      } else {
        // Vô hiệu hóa tất cả
        item.style.pointerEvents = 'none';
        item.setAttribute('data-disabled', 'true');
        item.classList.remove('hover:border-blue-400');
        
        // Đã chọn
        if (isSelectedAndCorrect) {
          // User chọn đúng - màu xanh
          item.classList.add('bg-green-100', 'border-green-400');
        } else if (isSelectedAndWrong) {
          // User chọn sai - màu đỏ
          item.classList.add('bg-red-100', 'border-red-400');
        } else if (isCorrectAnswerButNotSelected) {
          // Đáp án đúng nhưng user không chọn - xanh viền
          item.classList.add('bg-green-50', 'border-green-400');
        } else {
          // Các lựa chọn khác - disabled
          item.classList.add('border-gray-200');
          item.style.opacity = '0.6';
        }
      }
    });
  }
  
  // Update choice list for submit mode (only show selection, not correctness)
  function updateChoiceListSubmitMode(selectedIdx) {
    const container = document.querySelector(`[data-unique-question-id="${uniqueQuestionId}"]`);
    if (!container) return;
    
    const choiceListContainer = container.querySelector('[data-choice-list-container]');
    const choiceList = choiceListContainer?.querySelector('[data-choice-list]');
    const choiceItems = choiceList?.querySelectorAll('.choice-item');
    
    if (!choiceItems) return;
    
    choiceItems.forEach((item, idx) => {
      const isSelected = selectedIdx === idx;
      
      // Reset classes
      item.className = "choice-item p-3 border-2 rounded-lg transition-colors cursor-pointer";
      
      if (isSelected) {
        // Highlight selected (blue, not green/red)
        item.classList.add('bg-blue-100', 'border-blue-400');
      } else {
        item.classList.add('border-gray-200', 'hover:border-blue-400');
      }
    });
  }
  
  function showFeedback() {
    // Sử dụng unique ID để tránh conflict
    const container = document.querySelector(`[data-unique-question-id="${uniqueQuestionId}"]`);
    if (!container) return;
    
    const feedbackArea = container.querySelector('[data-feedback-area]');
    const feedbackMessage = feedbackArea?.querySelector('.feedback-message');
    const feedbackExplain = feedbackArea?.querySelector('.feedback-explain');
    
    if (!feedbackArea || !feedbackMessage) return;
    
    // Hiển thị feedback
    feedbackArea.classList.remove('hidden');
    
    // Tìm đáp án đúng để lấy chữ cái (sau khi shuffle)
    const choiceListContainer = container.querySelector('[data-choice-list-container]');
    const choiceList = choiceListContainer?.querySelector('[data-choice-list]');
    const correctItem = choiceList?.querySelector('[data-choice-is-correct="true"]');
    const correctLetter = correctItem?.getAttribute('data-choice-letter') || 'A';
    
    if (isCorrect) {
      // Chọn đúng
      feedbackArea.className = 'feedback-area mb-4 p-4 rounded-lg bg-green-50 border-2 border-green-200';
      feedbackMessage.className = 'feedback-message text-base font-medium text-green-800';
      feedbackMessage.textContent = '✅ Chính xác!';
      
      // Hiển thị explain nếu có
      if (feedbackExplain && explainText) {
        // Chuyển đổi markdown cơ bản thành HTML
        let htmlText = explainText
          // Xử lý horizontal rules trước
          .replace(/^---+$/gm, '<hr class="my-3 border-gray-300">') // horizontal rule
          // Xử lý headings
          .replace(/^### (.*?)$/gm, '<h3 class="text-base font-bold mt-4 mb-2">$1</h3>') // ### heading
          .replace(/^## (.*?)$/gm, '<h2 class="text-lg font-bold mt-4 mb-2">$1</h2>') // ## heading
          .replace(/^# (.*?)$/gm, '<h1 class="text-xl font-bold mt-4 mb-2">$1</h1>') // # heading
          // Xử lý xuống dòng
          .replace(/\n\n/g, '{{PARAGRAPH_BREAK}}') // double newline = paragraph break
          .replace(/\n/g, '<br>') // single newline = line break
          // Xử lý markdown formatting
          .replace(/\*\*(.*?)\*\*/g, '<strong class="font-semibold">$1</strong>') // **bold**
          .replace(/\*(.*?)\*/g, '<em>$1</em>') // *italic* (sau khi đã xử lý **)
          .replace(/^\- /gm, '• ') // bullet points ở đầu dòng
          // Chuyển paragraph breaks thành HTML
          .split('{{PARAGRAPH_BREAK}}')
          .map(para => {
            const trimmed = para.trim();
            // Nếu đã là heading hoặc hr thì không wrap trong <p>
            if (trimmed.startsWith('<h') || trimmed.startsWith('<hr')) {
              return trimmed;
            }
            return trimmed ? `<p class="mt-2">${trimmed}</p>` : '';
          })
          .join('');
        feedbackExplain.innerHTML = htmlText;
        feedbackExplain.className = 'feedback-explain mt-2 text-sm text-gray-700';
        
        // Hide explain if showExplain is false
        if (!showExplain) {
          feedbackExplain.classList.add('hidden');
        }
      }
    } else {
      // Chọn sai
      feedbackArea.className = 'feedback-area mb-4 p-4 rounded-lg bg-red-50 border-2 border-red-200';
      feedbackMessage.className = 'feedback-message text-base font-medium text-red-800';
      feedbackMessage.textContent = `❌ Chưa đúng. Đáp án đúng là: ${correctLetter}`;
      
      // Hiển thị explain
      if (feedbackExplain && explainText) {
        // Chuyển đổi markdown cơ bản thành HTML
        let htmlText = explainText
          // Xử lý horizontal rules trước
          .replace(/^---+$/gm, '<hr class="my-3 border-gray-300">') // horizontal rule
          // Xử lý headings
          .replace(/^### (.*?)$/gm, '<h3 class="text-base font-bold mt-4 mb-2">$1</h3>') // ### heading
          .replace(/^## (.*?)$/gm, '<h2 class="text-lg font-bold mt-4 mb-2">$1</h2>') // ## heading
          .replace(/^# (.*?)$/gm, '<h1 class="text-xl font-bold mt-4 mb-2">$1</h1>') // # heading
          // Xử lý xuống dòng
          .replace(/\n\n/g, '{{PARAGRAPH_BREAK}}') // double newline = paragraph break
          .replace(/\n/g, '<br>') // single newline = line break
          // Xử lý markdown formatting
          .replace(/\*\*(.*?)\*\*/g, '<strong class="font-semibold">$1</strong>') // **bold**
          .replace(/\*(.*?)\*/g, '<em>$1</em>') // *italic* (sau khi đã xử lý **)
          .replace(/^\- /gm, '• ') // bullet points ở đầu dòng
          // Chuyển paragraph breaks thành HTML
          .split('{{PARAGRAPH_BREAK}}')
          .map(para => {
            const trimmed = para.trim();
            // Nếu đã là heading hoặc hr thì không wrap trong <p>
            if (trimmed.startsWith('<h') || trimmed.startsWith('<hr')) {
              return trimmed;
            }
            return trimmed ? `<p class="mt-2">${trimmed}</p>` : '';
          })
          .join('');
        feedbackExplain.innerHTML = htmlText;
        feedbackExplain.className = 'feedback-explain mt-2 text-sm text-red-700';
        
        // Hide explain if showExplain is false
        if (!showExplain) {
          feedbackExplain.classList.add('hidden');
        }
      }
    }
  }
  
  // Helper function to dispatch answer event (after submission - with correct/incorrect info)
  function dispatchAnswerEvent() {
    const event = new CustomEvent('answer-submitted', {
      bubbles: true,
      detail: {
        questionId: uniqueQuestionId,
        selectedIndex,
        isCorrect
      }
    });
    const container = document.querySelector(`[data-unique-question-id="${uniqueQuestionId}"]`);
    if (container) {
      container.dispatchEvent(event);
    }
  }
  
  // Helper function to dispatch answer selected event (in submit mode - before submission)
  function dispatchAnswerSelectedEvent() {
    const event = new CustomEvent('answer-selected', {
      bubbles: true,
      detail: {
        questionId: uniqueQuestionId,
        selectedIndex,
        isCorrect // We know it but don't show to user yet
      }
    });
    const container = document.querySelector(`[data-unique-question-id="${uniqueQuestionId}"]`);
    if (container) {
      container.dispatchEvent(event);
    }
  }
  
  document.addEventListener('DOMContentLoaded', () => {
    // (Removed) Exam filter jump button
    // Sử dụng unique ID để tránh conflict khi có nhiều câu cùng id nhưng khác exam
    const container = document.querySelector(`[data-unique-question-id="${uniqueQuestionId}"]`);
    if (!container) return;
    
    const questionIdValue = container.getAttribute('data-question-id');
    
    // Bookmark functionality
    const bookmarkBtn = container.querySelector('.bookmark-btn');
    if (bookmarkBtn) {
      bookmarkBtn.addEventListener('click', () => {
        const isCurrentlyBookmarked = bookmarkBtn.getAttribute('data-is-bookmarked') === 'true';
        const newBookmarkState = !isCurrentlyBookmarked;
        
        bookmarkBtn.setAttribute('data-is-bookmarked', newBookmarkState.toString());
        bookmarkBtn.textContent = newBookmarkState ? '⭐' : '☆';
        
        // Dispatch event to parent
        const event = new CustomEvent('bookmark-toggle', {
          bubbles: true,
          detail: { questionId: uniqueQuestionId, isBookmarked: newBookmarkState }
        });
        container.dispatchEvent(event);
      });
    }
    
    // Toggle button cho dịch tiếng Việt
    const toggleBtn = container.querySelector('.toggle-vietnamese-btn');
    const vietnameseDiv = container.querySelector(`[data-vietnamese-translation="${questionIdValue}"]`);
    
    if (toggleBtn && vietnameseDiv) {
      // Initialize Vietnamese visibility based on default
      if (showVietnamese) {
        vietnameseDiv.classList.remove('hidden');
        toggleBtn.textContent = 'Ẩn dịch';
      }
      
      toggleBtn.addEventListener('click', () => {
        showVietnamese = !showVietnamese;
        if (showVietnamese) {
          vietnameseDiv.classList.remove('hidden');
          toggleBtn.textContent = 'Ẩn dịch';
        } else {
          vietnameseDiv.classList.add('hidden');
          toggleBtn.textContent = 'Hiện dịch';
        }
      });
    }

    // Toggle giải thích (ẩn/hiện)
    const toggleExplainBtn = container.querySelector('.toggle-explain-btn');
    if (toggleExplainBtn) {
      // Cập nhật nhãn theo state hiện tại
      function updateExplainBtnLabel() {
        toggleExplainBtn.textContent = showExplain ? 'Ẩn giải thích' : 'Hiện giải thích';
      }
      updateExplainBtnLabel();
      toggleExplainBtn.addEventListener('click', () => {
        showExplain = !showExplain;
        updateExplainBtnLabel();
        const feedbackExplain = container.querySelector('.feedback-explain');
        if (feedbackExplain) {
          if (showExplain) feedbackExplain.classList.remove('hidden');
          else feedbackExplain.classList.add('hidden');
        }
      });
    }
    
    // Lắng nghe event từ ChoiceList
    const choiceListContainer = container.querySelector('[data-choice-list-container]');
    const choiceList = choiceListContainer?.querySelector('[data-choice-list]');
    
    if (choiceList) {
      choiceList.addEventListener('choice-select', (e) => {
        const event = e;
        // Defensive check: đảm bảo event và detail tồn tại
        if (!event || !event.detail) {
          console.warn('Invalid event received:', event);
          return;
        }
        const clickedIndex = event.detail.index ?? 0;
        
        const currentCheckMode = getCurrentCheckMode();
        
        // Nếu đã submit trong submit mode thì không cho chọn nữa
        if (currentCheckMode === 'submit' && isSubmitted) return;
        
        // Nếu đã chọn rồi thì không làm gì (trong immediate mode)
        if (currentCheckMode === 'immediate' && selectedIndex !== null) return;
        
        // Kiểm tra xem đáp án đã chọn có đúng không (sau khi shuffle)
        const clickedItem = choiceList?.querySelector(`[data-choice-index="${clickedIndex}"]`);
        const isAnswerCorrect = (clickedItem?.getAttribute('data-original-index') === String(answerValue));
        
        // Cập nhật state
        selectedIndex = clickedIndex;
        isCorrect = isAnswerCorrect;
        
        // Cập nhật màu sắc choices (chỉ trong immediate mode)
        if (currentCheckMode === 'immediate') {
          updateChoiceList(selectedIndex);
          showFeedback();
          dispatchAnswerEvent();
        } else {
          // Submit mode: chỉ highlight đã chọn, không hiện đúng/sai, chờ nút nộp bài tổng
          updateChoiceListSubmitMode(selectedIndex);
          // Dispatch event để update ProgressBar (nhưng chưa xác định đúng/sai)
          dispatchAnswerSelectedEvent();
        }
      });
    }
    
    // Listen to reset event
    container.addEventListener('reset-question', () => {
      // Reset state
      selectedIndex = null;
      isCorrect = null;
      isSubmitted = false;
      
      // Reset choice list visual - remove all colors and selection
      const choiceListContainer = container.querySelector('[data-choice-list-container]');
      const choiceList = choiceListContainer?.querySelector('[data-choice-list]');
      const choiceItems = choiceList?.querySelectorAll('.choice-item');
      
      if (choiceItems) {
        choiceItems.forEach(item => {
          // Reset to default state
          item.className = "choice-item p-3 border-2 rounded-lg transition-colors cursor-pointer";
          item.classList.add('border-gray-200', 'hover:border-blue-400');
          item.style.opacity = '1';
        });
      }
      
      // Hide feedback area
      const feedbackArea = container.querySelector('[data-feedback-area]');
      if (feedbackArea) {
        feedbackArea.classList.add('hidden');
        const feedbackMessage = feedbackArea.querySelector('.feedback-message');
        const feedbackExplain = feedbackArea.querySelector('.feedback-explain');
        if (feedbackMessage) feedbackMessage.textContent = '';
        if (feedbackExplain) feedbackExplain.innerHTML = '';
      }
    });
    
    // Listen to submit-all event (from global submit button in submit mode)
    document.addEventListener('submit-all-answers', () => {
      // Only process if in submit mode and has selected answer
      if (getCurrentCheckMode() === 'submit' && selectedIndex !== null && !isSubmitted) {
        isSubmitted = true;
        
        // Show feedback
        showFeedback();
        updateChoiceList(selectedIndex);
        
        // Dispatch answer event
        dispatchAnswerEvent();
      }
    });
    
    // Listen to global settings changes
    document.addEventListener('settings-change', (e) => {
      const { setting, value } = e.detail;
      
      if (setting === 'showVietnamese' && vietnameseDiv && toggleBtn) {
        showVietnamese = value;
        if (value) {
          vietnameseDiv.classList.remove('hidden');
          toggleBtn.textContent = 'Ẩn dịch';
        } else {
          vietnameseDiv.classList.add('hidden');
          toggleBtn.textContent = 'Hiện dịch';
        }
      }
      
      if (setting === 'showExplain') {
        showExplain = value;
        const feedbackExplain = container.querySelector('.feedback-explain');
        if (feedbackExplain) {
          if (value) {
            feedbackExplain.classList.remove('hidden');
          } else {
            feedbackExplain.classList.add('hidden');
          }
        }
      }
      
      if (setting === 'checkMode' && container) {
        // Update checkMode from container attribute
        const newCheckMode = container.getAttribute('data-check-mode');
        if (newCheckMode && newCheckMode !== checkModeValue) {
          // Don't reload - checkModeValue will be read from attribute on next interaction
          console.log(`CheckMode updated from ${checkModeValue} to ${newCheckMode}`);
        }
      }
    });
  });
  })();
</script>
