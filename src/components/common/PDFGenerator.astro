---
export interface Props {
  markdown: string;
  slug: string;
  title: string;
  meaning: string;
  level: string;
  description: string;
  tags: string[];
}

const { slug } = Astro.props;
---

<button 
  class="flex items-center gap-2 px-3 py-2 text-slate-500 hover:text-red-600 hover:bg-red-50 rounded-lg transition-colors group" 
  id="pdf-generator-btn"
  data-slug={slug}
  title="Tải bài viết dưới dạng PDF"
>
  <svg class="w-5 h-5 group-hover:scale-110 transition-transform" fill="none" stroke="currentColor" viewBox="0 0 24 24">
    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 10v6m0 0l-3-3m3 3l3-3m2 8H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z"></path>
  </svg>
  <span class="text-sm font-medium">Tải PDF</span>
</button>

<script>
  import { jsPDF } from 'jspdf';
  import html2canvas from 'html2canvas';

  // --- Constants ---
  const CONFIG = {
    A4_WIDTH_MM: 210,
    A4_HEIGHT_MM: 297,
    MARGIN_TOP_MM: 20,
    MARGIN_BOTTOM_MM: 20,
    SCALE: 2 // Quality scale
  };
  
  document.addEventListener('DOMContentLoaded', function() {
    const pdfBtn = document.getElementById('pdf-generator-btn') as HTMLButtonElement;
    
    if (!pdfBtn) return;
    
    pdfBtn.addEventListener('click', async function() {
      const slug = this.dataset.slug || 'document';
      
      // UI Feedback: Loading
      const originalContent = this.innerHTML;
      this.innerHTML = `
        <svg class="animate-spin w-4 h-4 text-red-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24"><circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle><path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path></svg>
        <span class="text-sm">Đang tạo...</span>
      `;
      this.disabled = true;

      try {
        // 1. Selector: Target the correct new layout 'article'
        const content = document.querySelector('article');
        if (!content) throw new Error('Không tìm thấy nội dung bài viết');

        // 2. Clone Content for Manipulation
        // We create an invisible container to hold the clone with "PDF-specific" styles
        const pdfContainer = document.createElement('div');
        Object.assign(pdfContainer.style, {
          position: 'fixed',
          left: '-9999px',
          top: '0',
          width: '800px', // Fixed width for consistent rendering ~ A4
          padding: '40px',
          background: 'white',
          fontFamily: "'Times New Roman', serif", // Serif for print feel
          color: '#000',
          fontSize: '16px',
          lineHeight: '1.6'
        });

        // Add Header
        pdfContainer.innerHTML = `
          <div style="text-align: center; border-bottom: 2px solid #3b82f6; padding-bottom: 20px; margin-bottom: 30px;">
            <h1 style="color: #3b82f6; font-size: 24px; font-weight: bold; margin: 0;">THE FREE KOREAN</h1>
            <p style="font-size: 14px; color: #666; margin: 5px 0 0;">Ngữ pháp tiếng Hàn - thefreekorean.com</p>
          </div>
        `;

        const contentClone = content.cloneNode(true) as HTMLElement;

        // 3. Clean up the clone
        const removeSelectors = [
          'button', // All buttons
          '.share-button',
          '.navigation-buttons',
          '.related-grammar',
          'footer', // Nav footer
          '.not-prose', // Utility bars
           // Hidden elements
          '[style*="display: none"]',
          '.hidden'
        ];
        removeSelectors.forEach(s => contentClone.querySelectorAll(s).forEach(el => el.remove()));

        // 4. Style Overrides for Clone
        // flatten colors for print
        contentClone.querySelectorAll('*').forEach((el) => {
           const element = el as HTMLElement;
           // Ensure text contrast
           if (element.tagName === 'H1') element.style.color = '#000';
           if (element.tagName === 'P') element.style.color = '#111';
           // Expand collapsed items just in case
           element.style.maxHeight = 'none';
        });

        // Special handling for the header text badge
        const badges = contentClone.querySelectorAll('.rounded-full');
        badges.forEach(b => {
          (b as HTMLElement).style.border = '1px solid #ccc';
          (b as HTMLElement).style.backgroundColor = '#fff';
        });

        pdfContainer.appendChild(contentClone);
        
        // Add Footer
        const pdfFooter = document.createElement('div');
        pdfFooter.innerHTML = `
           <div style="margin-top: 40px; border-top: 1px solid #eee; padding-top: 20px; text-align: center; font-size: 12px; color: #999;">
             © The Free Korean | Tài liệu học tập miễn phí
           </div>
        `;
        pdfContainer.appendChild(pdfFooter);

        document.body.appendChild(pdfContainer);

        // 5. Capture with html2canvas (High Quality)
        const canvas = await html2canvas(pdfContainer, {
          scale: CONFIG.SCALE,
          useCORS: true,
          logging: false,
          backgroundColor: '#ffffff'
        });

        document.body.removeChild(pdfContainer);

        // 6. Generate PDF (Smart Split Logic)
        const pdf = new jsPDF({
          orientation: 'portrait',
          unit: 'mm',
          format: 'a4'
        });

        const imgWidth = CONFIG.A4_WIDTH_MM;
        const pageHeight = CONFIG.A4_HEIGHT_MM;
        const innerPageHeight = pageHeight - CONFIG.MARGIN_TOP_MM - CONFIG.MARGIN_BOTTOM_MM; // Usable height
        
        const pxToMm = imgWidth / canvas.width;
        const totalHeightMm = canvas.height * pxToMm;
        
        let heightLeft = totalHeightMm;
        let position = 0; // in mm relative to top of image
        let page = 0;

        // Simple slice approach is safer than complex detection for client-side
        // But we can try to minimize cutting text lines by small overlaps or smart offset
        // For now, standard pagination with margins.

        while (heightLeft > 0) {
          if (page > 0) pdf.addPage();
          
          // Calculate slice of image
          // Source Y (px) = position (mm) / pxToMm
          // Source Height (px) = innerPageHeight (mm) / pxToMm
          
          const srcY = position / pxToMm;
          const srcH = Math.min(innerPageHeight, heightLeft) / pxToMm;
          
          // Canvas for this page
          const pageCanvas = document.createElement('canvas');
          pageCanvas.width = canvas.width;
          pageCanvas.height = srcH; // Exact height of slice
          
          const ctx = pageCanvas.getContext('2d');
          if (ctx) {
             ctx.fillStyle = '#fff';
             ctx.fillRect(0, 0, pageCanvas.width, pageCanvas.height);
             
             ctx.drawImage(
               canvas,
               0, srcY, canvas.width, srcH, // Source
               0, 0, canvas.width, srcH     // Dest (draw full canvas)
             );

             // Add watermark to PDF page directly (vector text)
             pdf.setTextColor(200, 200, 200);
             pdf.setFontSize(40);
             pdf.text("THEFREEKOREAN.COM", 105, 148, { // Center
                 align: 'center',
                 angle: 45,
                 renderingMode: 'fill'
             });
             
             // Add Image to PDF
             const imgData = pageCanvas.toDataURL('image/jpeg', 0.95);
             pdf.addImage(imgData, 'JPEG', 0, CONFIG.MARGIN_TOP_MM, imgWidth, Math.min(innerPageHeight, heightLeft));
          }

          heightLeft -= innerPageHeight;
          position += innerPageHeight;
          page++;
        }

        pdf.save(`thefreekorean-${slug}.pdf`);

      } catch (err) {
        console.error('PDF Generation Error:', err);
        alert('Không thể tạo PDF lúc này. Vui lòng thử lại sau.');
      } finally {
        this.innerHTML = originalContent;
        this.disabled = false;
      }
    });
  });
</script>
